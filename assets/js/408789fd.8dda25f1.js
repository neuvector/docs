"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6247],{43997:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>i,contentTitle:()=>s,default:()=>p,frontMatter:()=>t,metadata:()=>r,toc:()=>d});var a=o(74848),c=o(28453);const t={title:"Namespace Boundary Enforcement",taxonomy:{category:"docs"},slug:"/policy/namespaceboundary"},s=void 0,r={id:"policy/namespaceboundary/namespaceboundary",title:"Namespace Boundary Enforcement",description:"Policy: Namespace Boundary Enforcement",source:"@site/docs/05.policy/14.namespaceboundary/14.namespaceboundary.md",sourceDirName:"05.policy/14.namespaceboundary",slug:"/policy/namespaceboundary",permalink:"/next/policy/namespaceboundary",draft:!1,unlisted:!1,editUrl:"https://github.com/neuvector/docs/edit/main/docs/05.policy/14.namespaceboundary/14.namespaceboundary.md",tags:[],version:"current",sidebarPosition:14,frontMatter:{title:"Namespace Boundary Enforcement",taxonomy:{category:"docs"},slug:"/policy/namespaceboundary"},sidebar:"tutorialSidebar",previous:{title:"Importing CRD from Console",permalink:"/next/policy/usingcrd/import"},next:{title:"6. Security Risks, Scanning & Compliance",permalink:"/next/scanning"}},i={},d=[{value:"Policy: Namespace Boundary Enforcement",id:"policy-namespace-boundary-enforcement",level:3}];function l(e){const n={blockquote:"blockquote",code:"code",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h3,{id:"policy-namespace-boundary-enforcement",children:"Policy: Namespace Boundary Enforcement"}),"\n",(0,a.jsx)(n.p,{children:'Customer made request to policy ingress/egress traffic on namespace\u2019s natural boundary.\neg.)\nThere are 2 namespaces ns1, ns2,\nin ns1 there are pod1 and pod2,\nin ns2 there are pod3 and pod4\ng1 is created using "label=app1" which includes pod1 and pod3\ng2 is created using "label=app2" which includes pod2 and pod4\nnetwork policy: from g1 to g2 app HTTPS port any action allow\nwith namespace boundary enforcement only pod1 can talk to pod2 but not pod1 to pod4, pod3 to pod4 but not pod3 to pod2, it saves user from creating additional rules to realize this restriction.'}),"\n",(0,a.jsx)("strong",{children:"Use label to enable/disable namespace boundary enforcement"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Add label to enable NBE"})}),"\n"]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["kubectl label namespace ",(0,a.jsx)(n.code,{children:"<namespace>"})," NeuvectorNamespaceBoundary=enabled"]}),"\n"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Remove or change label to disable NBE"})}),"\n"]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["kubectl label namespace ",(0,a.jsx)(n.code,{children:"<namespace>"})," NeuvectorNamespaceBoundary-\nor\nkubectl label namespace ",(0,a.jsx)(n.code,{children:"<namespace>"})," NeuvectorNamespaceBoundary=disabled"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},28453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>r});var a=o(96540);const c={},t=a.createContext(c);function s(e){const n=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:s(e.components),a.createElement(t.Provider,{value:n},e.children)}}}]);