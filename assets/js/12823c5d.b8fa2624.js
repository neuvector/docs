"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7724],{74195:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>t,metadata:()=>l,toc:()=>c});var s=i(85893),r=i(11151);const t={title:"CRD - Custom Resource Definitions",taxonomy:{category:"docs"},slug:"/policy/usingcrd"},o=void 0,l={id:"policy/usingcrd/usingcrd",title:"CRD - Custom Resource Definitions",description:"NeuVector CRD for Policy As Code",source:"@site/versioned_docs/version-5.3/05.policy/13.usingcrd/13.usingcrd.md",sourceDirName:"05.policy/13.usingcrd",slug:"/policy/usingcrd",permalink:"/policy/usingcrd",draft:!1,unlisted:!1,editUrl:"https://github.com/neuvector/docs/edit/main/versioned_docs/version-5.3/05.policy/13.usingcrd/13.usingcrd.md",tags:[],version:"5.3",sidebarPosition:13,frontMatter:{title:"CRD - Custom Resource Definitions",taxonomy:{category:"docs"},slug:"/policy/usingcrd"},sidebar:"tutorialSidebar",previous:{title:"Federated Policy",permalink:"/policy/federated"},next:{title:"Importing CRD from Console",permalink:"/policy/usingcrd/import"}},a={},c=[{value:"NeuVector CRD for Policy As Code",id:"neuvector-crd-for-policy-as-code",level:3},{value:"Supported Resource Types",id:"supported-resource-types",level:4},{value:"Generating a Sample NeuVector CRD",id:"generating-a-sample-neuvector-crd",level:3},{value:"Policy Mode Configuration and Group Definition",id:"policy-mode-configuration-and-group-definition",level:3},{value:"Policy Mode Configuration Requirements",id:"policy-mode-configuration-requirements",level:4},{value:"CRD Policy Rules Syntax and Semantics",id:"crd-policy-rules-syntax-and-semantics",level:3},{value:"RBAC Support with CRDs",id:"rbac-support-with-crds",level:3},{value:"Expressing Network Rules (Ingress, Egress objects) in CRDs",id:"expressing-network-rules-ingress-egress-objects-in-crds",level:3},{value:"Customized Configurations for Deployed Applications",id:"customized-configurations-for-deployed-applications",level:3},{value:"Policy Groups and Rules Migration Support",id:"policy-groups-and-rules-migration-support",level:3},{value:"CRD Samples for Global Rules",id:"crd-samples-for-global-rules",level:3},{value:"Updating CRD Rules and Adding to Existing Groups",id:"updating-crd-rules-and-adding-to-existing-groups",level:3},{value:"Dynamic criteria support for NvClusterSecurityRule",id:"dynamic-criteria-support-for-nvclustersecurityrule",level:4}];function d(e){const n={admonition:"admonition",code:"code",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h3,{id:"neuvector-crd-for-policy-as-code",children:"NeuVector CRD for Policy As Code"}),"\n",(0,s.jsx)(n.p,{children:"NeuVector custom resource definitions (CRDs) can be used by various teams to automatically define security policies in the NeuVector container security platform. Developers, DevOps, DevSecOps, and Security teams can collaborate to automate security policies for new or updated applications deployed to production. CRDs can also be used to enforce global security policies across multiple Kubernetes clusters."}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"CRDs are supported in Kubernetes 1.11 and later. Deploying the NeuVector security rule CRD in earlier versions may not result in an error, but the CRD will not be processed."})}),"\n",(0,s.jsx)(n.p,{children:"CRD's can be used to support many use cases and workflows:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Define security policy during application development, to push into production."}),"\n",(0,s.jsx)(n.li,{children:"Learn behavior using NeuVector and export the CRD for review before pushing into production."}),"\n",(0,s.jsx)(n.li,{children:"Migrate security policies from staging to production clusters."}),"\n",(0,s.jsx)(n.li,{children:"Replicate rules across multiple replicated clusters in hybrid or multi-clouds."}),"\n",(0,s.jsx)(n.li,{children:"Enforce global security policies (see examples for this at bottom)."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"CRD's bring many benefits, including:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Define / declare the security policy, as code."}),"\n",(0,s.jsx)(n.li,{children:"Version and track the security policies the same as application deployment manifests."}),"\n",(0,s.jsx)(n.li,{children:"Define the allowed behavior of any application including network, file and process behavior."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"supported-resource-types",children:"Supported Resource Types"}),"\n",(0,s.jsx)(n.p,{children:"NeuVector supports two kinds of custom resource definitions.  They are the NvSecurityRule and NvClusterSecurityRule.  The difference among the two comes down to the boundary set by the definition of the scope.  The  NvSecurityRule resource is scoped at the namespace level, whereas the NvClusterSecurityRule is scoped at the cluster level.  Either of the resource types can be configured in a yaml file and can be created during deployment, as shown in the deployment instructions and examples for NeuVector."}),"\n",(0,s.jsx)(n.p,{children:"The significance of the NvSecurityRule resource type with a scope of namespace lies in the enforcement of the configured domain of the target group, which must match the configured namespace in the NeuVector\u2019s  CRD security policy.  This provides enforcement to prevent unwanted cross-namespace policy creation which affect a Target-Group policy rule."}),"\n",(0,s.jsx)(n.p,{children:"For the NvClusterSecurityRule custom resource definition, this has a cluster level scope, and therefore, does not enforce any namespace boundary on a defined target.  However, the user-context that is used for importing the CRD-yaml file must have the necessary permissions to access or reside in the same namespace as the one configured in the CRD-yaml file, or the import will be rejected."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("strong",{children:"Enabling CRD Support"}),"\nAs described in the Kubernetes and OpenShift deployment sections (Deploying NeuVector),  the appropriate clusterroles and clusterrole bindings for custom resources and NvSecurityRules should be added first."]}),"\n",(0,s.jsx)(n.p,{children:"Then NvSecurityRule and NvClusterSecurityRule should be created using the sample yaml in those sections. NeuVector CRDs can now be deployed."}),"\n",(0,s.jsx)(n.h3,{id:"generating-a-sample-neuvector-crd",children:"Generating a Sample NeuVector CRD"}),"\n",(0,s.jsx)(n.p,{children:"The simplest way to see how the yaml file format looks for a NeuVector CRD is to export it from the NeuVector Console. After you have tested your application while NeuVector is in Discover mode learning the network, file, and process behavior, you can export the learned policy."}),"\n",(0,s.jsx)(n.p,{children:"Go to the Policy -> Groups menu and click on Export Group Policy from the upper right."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"CRDExport",src:i(49633).Z+"",width:"2234",height:"1120"})}),"\n",(0,s.jsx)(n.p,{children:"Then select the Groups that you wish to export, such as the three in the demo namespace above. Inspect the saved CRD yaml below to see how the NeuVector network, process, and file rules are expressed."}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"In addition to the selected group(s), all 'linked' groups will also be exported. A linked group is any other group that a selected group will connect to or from as allowed by a network rule."})}),"\n",(0,s.jsx)(n.p,{children:"Sample Exported CRD"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\nitems:\n- apiVersion: neuvector.com/v1\n  kind: NvSecurityRule\n  metadata:\n    name: nv.nginx-pod.demo\n    namespace: demo\n  spec:\n    egress:\n    - selector:\n        criteria:\n        - key: service\n          op: =\n          value: node-pod.demo\n        - key: domain\n          op: =\n          value: demo\n        name: nv.node-pod.demo\n      action: allow\n      applications:\n      - HTTP\n      name: nv.node-pod.demo-egress-0\n      ports: any\n    file: []\n    ingress:\n    - selector:\n        criteria:\n        - key: service\n          op: =\n          value: exploit.demo\n        - key: domain\n          op: =\n          value: demo\n        name: nv.exploit.demo\n      action: allow\n      applications:\n      - HTTP\n      name: nv.nginx-pod.demo-ingress-0\n      ports: any\n    process:\n    - action: allow\n      name: nginx\n      path: /usr/sbin/nginx\n    - action: allow\n      name: pause\n      path: /pause\n    - action: allow\n      name: ps\n      path: /bin/ps\n    target:\n      selector:\n        criteria:\n        - key: service\n          op: =\n          value: nginx-pod.demo\n        - key: domain\n          op: =\n          value: demo\n        name: nv.nginx-pod.demo\n      policymode: Monitor\n- apiVersion: neuvector.com/v1\n  kind: NvSecurityRule\n  metadata:\n    name: nv.node-pod.demo\n    namespace: demo\n  spec:\n    egress:\n    - selector:\n        criteria:\n        - key: address\n          op: =\n          value: google.com\n        name: test\n      action: allow\n      applications:\n      - SSL\n      name: test-egress-1\n      ports: any\n    - selector:\n        criteria:\n        - key: service\n          op: =\n          value: redis-pod.demo\n        - key: domain\n          op: =\n          value: demo\n        name: nv.redis-pod.demo\n      action: allow\n      applications:\n      - Redis\n      name: nv.redis-pod.demo-egress-2\n      ports: any\n    - selector:\n        criteria:\n        - key: service\n          op: =\n          value: kube-dns.kube-system\n        - key: domain\n          op: =\n          value: kube-system\n        name: nv.kube-dns.kube-system\n      action: allow\n      applications:\n      - DNS\n      name: nv.kube-dns.kube-system-egress-3\n      ports: any\n    file: []\n    ingress: []\n    process:\n    - action: allow\n      name: curl\n      path: ""\n    - action: allow\n      name: node\n      path: /usr/bin/nodejs\n    - action: allow\n      name: pause\n      path: /pause\n    - action: allow\n      name: ps\n      path: /bin/ps\n    - action: allow\n      name: sh\n      path: /bin/dash\n    - action: allow\n      name: whoami\n      path: /usr/bin/whoami\n    target:\n      selector:\n        criteria:\n        - key: service\n          op: =\n          value: node-pod.demo\n        - key: domain\n          op: =\n          value: demo\n        name: nv.node-pod.demo\n      policymode: Protect\n- apiVersion: neuvector.com/v1\n  kind: NvSecurityRule\n  metadata:\n    name: nv.redis-pod.demo\n    namespace: demo\n  spec:\n    egress: []\n    file: []\n    ingress: []\n    process:\n    - action: allow\n      name: pause\n      path: /pause\n    - action: allow\n      name: redis-server\n      path: /usr/local/bin/redis-server\n    target:\n      selector:\n        criteria:\n        - key: service\n          op: =\n          value: redis-pod.demo\n        - key: domain\n          op: =\n          value: demo\n        name: nv.redis-pod.demo\n      policymode: Monitor\n- apiVersion: neuvector.com/v1\n  kind: NvSecurityRule\n  metadata:\n    name: nv.kube-dns.kube-system\n    namespace: kube-system\n  spec:\n    egress: null\n    file: null\n    ingress: null\n    process: null\n    target:\n      selector:\n        criteria:\n        - key: service\n          op: =\n          value: kube-dns.kube-system\n        - key: domain\n          op: =\n          value: kube-system\n        name: nv.kube-dns.kube-system\n      policymode: Monitor\n- apiVersion: neuvector.com/v1\n  kind: NvSecurityRule\n  metadata:\n    name: nv.exploit.demo\n    namespace: demo\n  spec:\n    egress: null\n    file: null\n    ingress: null\n    process: null\n    target:\n      selector:\n        criteria:\n        - key: service\n          op: =\n          value: exploit.demo\n        - key: domain\n          op: =\n          value: demo\n        name: nv.exploit.demo\n      policymode: Monitor\nkind: List\nmetadata: null\n'})}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"This is a namespaced CRD, of NvSecurityRule"}),"\n",(0,s.jsx)(n.li,{children:"nginx-pod.demo can talk to node-pod.demo over HTTP, and allowed processes are listed"}),"\n",(0,s.jsx)(n.li,{children:"node-pod.demo can talk to redis-pod.demo using the Redis protocol"}),"\n",(0,s.jsx)(n.li,{children:"The policymode of the services are set to Monitor mode"}),"\n",(0,s.jsx)(n.li,{children:"node-pod.demo is allowed to egress to google.com using SSL"}),"\n",(0,s.jsx)(n.li,{children:"Group names such as nv.node-pod.demo are referenced but not defined in the CRD, so are expected to already exist when deployed. See below for defining Groups."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"policy-mode-configuration-and-group-definition",children:"Policy Mode Configuration and Group Definition"}),"\n",(0,s.jsx)(n.p,{children:"Policy mode configuration and Group definition is supported within the CRD configuration yaml file.  With policymode configured in the yaml configuration file, importing such file will set the target group to this value for the CRD import."}),"\n",(0,s.jsx)(n.admonition,{title:"important",type:"warning",children:(0,s.jsx)(n.p,{children:"The imported target policy mode is not allowed to be modified from the NeuVector console (Policy -> Groups). For example, once the mode is set to Monitor, it can only be changed through CRD modification, not through the console."})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"The CRD import behavior ignores the PolicyMode of any 'linked' group, leaving the Policy mode unchanged if the linked group already exists. If the linked group does not exist it will be automatically created and set to the default New Services Mode in Settings -> Configuration."})}),"\n",(0,s.jsx)(n.h4,{id:"policy-mode-configuration-requirements",children:"Policy Mode Configuration Requirements"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Mode only applies to the configured Target group"}),"\n",(0,s.jsxs)(n.li,{children:["The target group configuration must have the format nv.SERVICE_NAME.DOMAIN.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Example:  nv.xxx.yyy"}),"\n",(0,s.jsx)(n.li,{children:"xxx.yyy=SERVICE"}),"\n",(0,s.jsx)(n.li,{children:"yyy=DOMAIN"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Supported values are Discover, Monitor, and Protect"}),"\n",(0,s.jsx)(n.li,{children:"The target group must contain the key-value pair key: service"}),"\n",(0,s.jsx)(n.li,{children:"A configured key: domain must match the service domain suffix with the configured service key-value pair"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Policy Mode Configuration Yaml file Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'  target:\n      policymode: Protect\n      selector:\n          name: nv.xxx.yyy\n          criteria:\n          - key: service            #1 of 2 Criteria must exist\n            value: xxx.yyy\n            op: "="\n          - key: domain             #2 of 2 Criteria must exist\n            value: yyy\n            op: "="\n'})}),"\n",(0,s.jsx)(n.h3,{id:"crd-policy-rules-syntax-and-semantics",children:"CRD Policy Rules Syntax and Semantics"}),"\n",(0,s.jsx)("strong",{children:"Group Name"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Avoid using names which start with fed., nv.ip., host:, or workload: which are reserved for federated groups or ip based services."}),"\n",(0,s.jsx)(n.li,{children:"You can use node, external, or containers as a group name. However, this will be the same as the reserved default group names, so a new group will not be created. Any group definition criteria in the CRD will be ignored, but the rules for the group will be processed. The new rules will be shown under the group name."}),"\n",(0,s.jsx)(n.li,{children:"Meets the criteria: ^[a-zA-Z0-9]+[.:a-zA-Z0-9_-]*$"}),"\n",(0,s.jsx)(n.li,{children:"Must not begin with fed, workload, or nv.ip"}),"\n",(0,s.jsx)(n.li,{children:"If the name has the format as nv.xxx.yyy, then there must exist a matching service and domain definition, or the import validation will fail.  Please refer to the above Policy Mode Configuration for details."}),"\n",(0,s.jsx)(n.li,{children:"If the group name to be imported already exists in the destination system, then the criteria must match between the imported CRD and the one in the destination system.  If there are differences, the CRD import will be rejected."}),"\n"]}),"\n",(0,s.jsx)("strong",{children:"Policy Name"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Needs to be unique within a yaml file."}),"\n",(0,s.jsx)(n.li,{children:"Cannot be empty."}),"\n"]}),"\n",(0,s.jsx)("strong",{children:"Ingress"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Is the traffic inbound to the target."}),"\n"]}),"\n",(0,s.jsx)("strong",{children:"Egress"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Is the traffic leaving from the target."}),"\n"]}),"\n",(0,s.jsx)("strong",{children:"Criteria"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Must not be empty unless the name is nodes, external, or containers"}),"\n",(0,s.jsx)(n.li,{children:"name - If the name has the service format nv.xxx.yyy, then refer to the above section Policy Mode Configuration section details"}),"\n",(0,s.jsx)(n.li,{children:"key - The key conforms to the regular expression pattern ^[a-zA-Z0-9]+[.:a-zA-Z0-9_-]*$"}),"\n",(0,s.jsxs)(n.li,{children:["op (operation)","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'string = "="'}),"\n",(0,s.jsx)(n.li,{children:'string = "!="'}),"\n",(0,s.jsx)(n.li,{children:'string = "contains"'}),"\n",(0,s.jsx)(n.li,{children:'string = "prefix"'}),"\n",(0,s.jsx)(n.li,{children:'string = "regex"'}),"\n",(0,s.jsx)(n.li,{children:'string = "!regex"'}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"value - A string without limitations"}),"\n",(0,s.jsx)(n.li,{children:"key - Must not be empty"}),"\n",(0,s.jsxs)(n.li,{children:["op - Operator","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If the operator is equal (=) or not-equal (!=), then its\u2019 value must not be empty."}),"\n",(0,s.jsx)(n.li,{children:"If the operator is equal (=) or not-equal (!=) with a value (such as * or ?), then the value cannot have any regular expresssion format like ^$."}),"\n",(0,s.jsx)(n.li,{children:"Example:"}),"\n",(0,s.jsx)(n.li,{children:"Key: service"}),"\n",(0,s.jsx)(n.li,{children:"Op :  ="}),"\n",(0,s.jsx)(n.li,{children:"Value: ab?c*e^$  (this is incorrect)"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Action - Allow or deny"}),"\n",(0,s.jsxs)(n.li,{children:["Applications (supported values)","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"ActiveMQ"}),"\n",(0,s.jsx)(n.li,{children:"Apache"}),"\n",(0,s.jsx)(n.li,{children:"Cassandra"}),"\n",(0,s.jsx)(n.li,{children:"Consul"}),"\n",(0,s.jsx)(n.li,{children:"Couchbase"}),"\n",(0,s.jsx)(n.li,{children:"CouchDB"}),"\n",(0,s.jsx)(n.li,{children:"DHCP"}),"\n",(0,s.jsx)(n.li,{children:"DNS"}),"\n",(0,s.jsx)(n.li,{children:"Echo"}),"\n",(0,s.jsx)(n.li,{children:"ElasticSearch"}),"\n",(0,s.jsx)(n.li,{children:"etcd"}),"\n",(0,s.jsx)(n.li,{children:"GRPC"}),"\n",(0,s.jsx)(n.li,{children:"HTTP"}),"\n",(0,s.jsx)(n.li,{children:"Jetty"}),"\n",(0,s.jsx)(n.li,{children:"Kafka"}),"\n",(0,s.jsx)(n.li,{children:"Memcached"}),"\n",(0,s.jsx)(n.li,{children:"MongoDB"}),"\n",(0,s.jsx)(n.li,{children:"MSSQL"}),"\n",(0,s.jsx)(n.li,{children:"MySQL"}),"\n",(0,s.jsx)(n.li,{children:"nginx"}),"\n",(0,s.jsx)(n.li,{children:"NTP"}),"\n",(0,s.jsx)(n.li,{children:"Oracle"}),"\n",(0,s.jsx)(n.li,{children:"PostgreSQL"}),"\n",(0,s.jsx)(n.li,{children:"RabbitMQ"}),"\n",(0,s.jsx)(n.li,{children:"Radius"}),"\n",(0,s.jsx)(n.li,{children:"Redis"}),"\n",(0,s.jsx)(n.li,{children:"RTSP"}),"\n",(0,s.jsx)(n.li,{children:"SIP"}),"\n",(0,s.jsx)(n.li,{children:"Spark"}),"\n",(0,s.jsx)(n.li,{children:"SSH"}),"\n",(0,s.jsx)(n.li,{children:"SSL"}),"\n",(0,s.jsx)(n.li,{children:"Syslog"}),"\n",(0,s.jsx)(n.li,{children:"TFTP"}),"\n",(0,s.jsx)(n.li,{children:"VoltDB"}),"\n",(0,s.jsx)(n.li,{children:"Wordpress"}),"\n",(0,s.jsx)(n.li,{children:"ZooKeeper"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Port - The specified format is xxx/yyy. Where xxx=protocol(tcp, udp), and yyy=port_number (0-65535).","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"TCP/123 or TCP/any"}),"\n",(0,s.jsx)(n.li,{children:"UDP/123 or UDP/123"}),"\n",(0,s.jsx)(n.li,{children:"ICMP"}),"\n",(0,s.jsx)(n.li,{children:"123 = TCP/123"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Process - A list of process with action, name, path for each","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"action: allow/deny  #This action has precedence over the file access rule.  This should be set to allow if the intent is to allow the file access rule to take effect."}),"\n",(0,s.jsx)(n.li,{children:"name: process name"}),"\n",(0,s.jsx)(n.li,{children:"path: process path (optional)"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["File - A list of file access rules; these apply only to the defined target container group","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"app: list of apps"}),"\n",(0,s.jsx)(n.li,{children:"behavior: block_access / monitor_change  #This blocks access to the defined filter below.  If monitor_change is chosen, then a security-event will be generated from the NeuVector\u2019s webconsole Notifications > Security events page."}),"\n",(0,s.jsx)(n.li,{children:"filter:  path/filename"}),"\n",(0,s.jsx)(n.li,{children:"recursive: true/false"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"rbac-support-with-crds",children:"RBAC Support with CRDs"}),"\n",(0,s.jsx)(n.p,{children:"Utilizing Kubernetes existing RBAC model, NeuVector extends the CRD (Custom Resource Definition) to support RBAC by utilizing Kubernetes\u2019s Rolebinding in association with the configured Namespace in the NeuVector  configured CRD rules when using the NvSecurityRule resource-type. This configured Namespace is then used to enforce the configured Target, which must reside in this namespace configured in the NeuVector security policy. When rolebinding a defined clusterrole, this can be used to bind to a Kubernetes User or Group. The two clusterrole resources types that NeuVector supports are NvSecurityRule and NvClusterSecurityRule."}),"\n",(0,s.jsx)("strong",{children:"Rolebinding & Clusterolebinding with 2 Users in different Namespaces to a Clusterrole\n(NvSecurityRules & NvClusterSecurityRules resources)"}),"\n",(0,s.jsx)(n.p,{children:"The following illustrates a scenario creating one Clusterrole containing both resources (NvSecurityRules and NvClusterSecurityRules) to be bound to two different users."}),"\n",(0,s.jsx)(n.p,{children:"One user (user1) belongs to Namespace (ns1), while the other user (user2) belongs to Namespace (ns2).  User1 will Rolebind to this created Clusterrole (nvsecnvclustrole), while User2 is Clusterrolebind to this same Clusterrole (nvsecnvclustrole)."}),"\n",(0,s.jsx)(n.p,{children:"The key takeaway here is to illustrate that using Rolebinding, this will have Namespace-Level-Scope, whereas using Clusterrolebinding will have Cluster-Level-Scope.  User1 will Rolebind (Namespace-Level-Scope), and User2 will be Clusterrolebind (Cluster-Level-Scope).  This matters most during RBAC enforcement based on the scope-level that bounds the created users access."}),"\n",(0,s.jsx)("strong",{children:"Example using 2 different types of defined yaml files, and the effect of using each user"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Create a Clusterrole containing both NvSecurityRules and NvClusterSecurityRules resources.\nNote: Notice that this clusterrole has 2 resources configured, nvsecurityrules and nvclustersecurityrules. Example (nvsecnvclustroles.yaml):"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n   name: nvsecnvclustrole\nrules:\n- apiGroups:\n  - neuvector.com\n  resources:\n  - nvsecurityrules\n  - nvclustersecurityrules\n  verbs:\n  - list\n  - delete\n  - create \n  - get \n  - update\n- apiGroups:\n  - apiextensions.k8s.io\n  resources:\n  - customresourcedefinitions\n  verbs:\n  - get\n  - list\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:["Create 2 test yaml-files. One for the NvSecurityRules, and the other for the NvClusterSecurityRules resource.\nSample ",(0,s.jsx)(n.code,{children:"NvSecurityRules"})," nvsecurity.yaml file:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'apiVersion: neuvector.com/v1\nkind:     NvSecurityRule\nmetadata:\n  name:    ns1crd\n  namespace: ns1\nspec:\n  target:\n      selector:\n          name: nv.nginx-pod.ns1\n          criteria:\n          - key: service\n            value: nginx-pod.ns1\n            op: "="\n          - key: domain\n            value: ns1\n            op: "="\n  ingress: \n      -   \n        selector:\n            name: ingress\n            criteria:\n            - key: domain\n              value: demo\n              op: "=" \n        ports: "tcp/65535"\n        applications: \n            - SSL\n        action:  allow \n        name:    ingress\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Sample ",(0,s.jsx)(n.code,{children:"NvClusterSecurityRules"})," nvclustersecurity.yaml file:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'apiVersion: neuvector.com/v1\nkind:     NvClusterSecurityRule\nmetadata:\n  name:    rbacnvclustmatchnamespacengtargserving\n  namespace: nvclusterspace \nspec:\n  target:\n      policymode: Protect\n      selector:\n          name: nv.nginx-pod.eng\n          criteria:\n          - key: service\n            value: nginx-pod.eng\n            op: "="\n          - key: domain\n            value: eng\n            op: "="\n  ingress: \n      -   \n        selector:\n            name: ingress\n            criteria:\n            - key: service\n              value: nginx-pod.demo\n              op: "=" \n        ports: "tcp/65535"\n        applications: \n            - SSL\n        action:  allow \n        name:    ingress\n'})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"Switching the user-context to user1 (belongs to the ns1 Namespace) has a Rolebind to the NvSecurityRules resource, who is Namespace bound to the Namespace ns1.  Therefore, importing test yaml file (kubectl create \u2013f nvsecurity.yaml should be allowed since this yaml file configuration has the NvSecurityRules resource and the Namespace that this user is bound to."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If there is an attempt to import the test yaml file (nvclustersecurity.yaml ) however, this will be denied since the import CRD yaml file is defined with the resource NvClusterSecurityRules that has a Cluster-Scope, but user1 was Rolebind with a Namespace-Scope.  Namespace-scope has a lower privilege than Cluster-Scope.  Therefore, Kubernetes RBAC will deny such a request."}),"\n",(0,s.jsx)(n.p,{children:"Example Error Message:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:'Error from server (Forbidden): error when creating "rbacnvclustnamespacengtargnvclustingress.yamltmp": nvclustersecurityrules.neuvector.com is forbidden: User "user1" cannot create resource "nvclustersecurityrules" in API group "neuvector.com" at the cluster scope\n'})}),"\n",(0,s.jsx)(n.p,{children:"Next, we can switch the user-context to user2 with a broader scope privilege, cluster-level-scope.  This user2 has a Clusterrolebinding that is not Namespace bound, but has a cluster-level-scope, and associates with the NvClusterSecurityRules resource."}),"\n",(0,s.jsx)(n.p,{children:"Therefore, using user2 to import either yaml file (nvsecurity.yaml\nor nvclustersecurity.yaml) will be allowed, since this user\u2019s Clusterrolebinding is not restricted to either resource NvSecurityRules (Namespace-Scope) or NvClusterSecurityRules (Cluster-Scope)."}),"\n",(0,s.jsx)(n.h3,{id:"expressing-network-rules-ingress-egress-objects-in-crds",children:"Expressing Network Rules (Ingress, Egress objects) in CRDs"}),"\n",(0,s.jsx)(n.p,{children:"Network rules expressed in CRDs have an Ingress and/or Egress object, which define the allowed incoming and outgoing connections (protocols, ports etc) to/from the workload (Group). Each network rule in NeuVector must have a unique name in a CRD. Note that in the console, network rules only have a unique ID number."}),"\n",(0,s.jsx)(n.p,{children:"If the 'To' (destination) of the rule is a learned, discovered group, upon export NeuVector prepends the 'nv.' identifier to the name. For example \"nv.redis-master.demo-ingress-0\". For both discovered and custom groups, NeuVector also appends a unique name identifier, such as '-ingress-0' in the rule name 'nv.redis-master.demo-ingress-0. For CRD rule names, the 'nv.' identifier is NOT required, and is added to exported rules for clarity. For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"    ingress:\n    - action: allow\n      applications:\n      - Redis\n      name: nv.redis-master.demo-ingress-0\n"})}),"\n",(0,s.jsx)(n.p,{children:"Custom, user created groups are not allowed to have the 'nv.' prefix. Only discovered/learned groups with the domain and service objects should have the prefix. For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'    - action: allow\n      applications:\n      - HTTP\n      name: nv.node-pod.demo-egress-1\n      ports: any\n      priority: 0\n      selector:\n        comment: ""\n        criteria:\n        - key: service\n          op: =\n          value: node-pod.demo\n        - key: domain\n          op: =\n          value: demo\n        name: nv.node-pod.demo\n'})}),"\n",(0,s.jsx)(n.h3,{id:"customized-configurations-for-deployed-applications",children:"Customized Configurations for Deployed Applications"}),"\n",(0,s.jsx)(n.p,{children:"With the use of a customized CRD yaml file, this enables you to customize network security rules, file access rules, and process security rules, all bundled into a single configuration file.  There are multiple benefits to allow these customizations."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"First, this allows the same rules to be applied on multiple Kubernetes environments, allowing synchronization among clusters."}),"\n",(0,s.jsx)(n.li,{children:"Second, this allows preemptive rules deployment prior to the applications coming online, which provides a proactive and effective security rules deployment workflow."}),"\n",(0,s.jsx)(n.li,{children:"Third, this allows the policymode to change from an evaluation one (such as Discover or Monitor), to one that protects the final staging environment."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These CRD rules within a yaml file can be imported into the NeuVector security platform through the use of Kubernetes CLI commands such as 'kubectl create \u2013f crd.yaml'.  This empowers the security team to tailor the security rules to be applied upon various containers residing in the Kubernetes environment."}),"\n",(0,s.jsx)(n.p,{children:"For example, a particular yaml file can be configured to enable the policymode to Discover or Monitor a particular container named nv.alpine.ns1 in a staging cluster environment.  Moreover, you can limit ssh access for a configured target container nv.alpine.ns1. to another container nv.redhat.ns2."}),"\n",(0,s.jsx)(n.p,{children:"Once all the necessary tests and evaluations of such security rules are deemed correct, then you can migrate this to a production cluster environment simultaneous to the application deployments by using the NeuVector policy migration feature, which will be discussed later in this section."}),"\n",(0,s.jsx)("strong",{children:"Examples of CRD configurations that perform these functions"}),"\n",(0,s.jsx)(n.p,{children:"The following is a sample snippet of such configurations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'apiVersion: neuvector.com/v1\nkind:     NvSecurityRule\nmetadata:\n  name:    ns1global\n  namespace: ns1              #The target\'s native namespace\nspec:\n  target:\n      selector:\n          name: nv.alpine.ns1\n          criteria:\n          - key: service\n            value: alpine.ns1   #The source target\'s running container\n            op: "="\n          - key: domain\n            value: ns1\n            op: "="\n  egress:\n      - \n        selector:\n            name: egress\n            criteria:\n            - key: service\n              value: nv.redhat.ns2      #The destination\'s running container    \n              op: "="\n        ports:   tcp/22                     #Denies ssh to the destination container nv.redhat.ns2\n        applications:\n            - SSH\n        action:  deny \n        name:    egress\n  file:                                       #Applies only to the defined target container group\n  - app:\n    - chmod                              #The application chmod is the only application allowed to access, while all other apps are denied.\n    behavior: block_access      #Supported values are block_access and monitor_change.  This blocks access to the defined filter below.\n    filter: /tmp/passwd.txt\n    recursive: false\n  process:\n  - action: allow                  #This action has precedence over the file access rule.  This should be allowed if the intent is to allow the file access rule to take effect.\n    name: chmod                # This configured should match the application defined under the file section.\n    path: /bin/chmod\n'})}),"\n",(0,s.jsx)(n.p,{children:"The above snippet is configured to enforce ssh access from the target group container nv.alpine.ns1 to the egress group nv.redhat.ns2.  In addition, the enforcement of file access and the process rules are defined and applied to the configured target container nv.alpine.ns1.  With this bundled configuration, we have allowed the defined network, file, and process security rules to act upon the configured target group."}),"\n",(0,s.jsx)(n.h3,{id:"policy-groups-and-rules-migration-support",children:"Policy Groups and Rules Migration Support"}),"\n",(0,s.jsx)(n.p,{children:"NeuVector supports the exporting of certain NeuVector group types from a Kubernetes cluster in a yaml file and importing into another Kubernetes cluster by utilizing native kubectl commands."}),"\n",(0,s.jsx)("strong",{children:"Migration Use Cases"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Export tested CRD groups and security rules that are deemed \u201cproduction ready\u201d from a staging k8s cluster environment to a production k8s cluster environment."}),"\n",(0,s.jsx)(n.li,{children:"Export learned security rules to be migrated from a staging k8s environment to a production k8s environment."}),"\n",(0,s.jsx)(n.li,{children:"Allow the modification of the policymode of a configured Target group, for instance, such as Discover or Monitor mode in a staging environment, to Protect mode in a production environment."}),"\n"]}),"\n",(0,s.jsx)("strong",{children:"Supported Export Conditions"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Target, Ingress, Egress, Self-learned"}),"\n"]}),"\n",(0,s.jsx)("strong",{children:"Example of groups export"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Exported groups with a configured attribute as domain=xx are exported with the Resource-Type NvsecurityRule along with the namespace."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"GroupExport",src:i(75232).Z+"",width:"750",height:"597"})}),"\n",(0,s.jsx)("strong",{children:"Example of an exported group yaml file with the NvsecurityRule resource type"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"  kind: NvSecurityRule\n  metadata:\n    name: nv.nginx-pod.neuvector\n    namespace: neuvector\n  spec:\n    egress: []\n    file: []\n    ingress: []\n    process: []\n    target:\n      selector:\n        criteria:\n        - key: service\n          op: =\n          value: nginx-pod.neuvector\n        - key: domain\n          op: =\n          value: neuvector\n        name: nv.nginx-pod.neuvector\n      policymode: Discover\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Exported groups without the defined criteria as domain=xx (Namespace) are exported with a Resource-Type NvClusterSecurityRule and a Namespace as default.  Examples of Exported groups without a Namespace are external, container, etc."}),"\n"]}),"\n",(0,s.jsx)("strong",{children:"Example of an exported group yaml file with the NvClusterSecurityRule resource type"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"  kind: NvClusterSecurityRule\n  metadata:\n    name: egress\n    namespace: default\n  spec:\n    egress: []\n    file:             #File path profile applicable to the Target group only, and only applies to self-learned and user create groups \n    - app:\n      - vi\n      - cat     \n      behavior: block_access\n      filter: /etc/mysecret              #Only vi and cat can access this file with \u201cblock_access\u201d.\n      recursive: false\n    ingress:\n    - selector:\n        criteria:\n        - key: service\n          op: =\n          value: nginx-pod.neuvector\n        - key: domain\n          op: =\n          value: neuvector\n        name: nv.nginx-pod.neuvector     #Group Name\n      action: allow\n      applications:\n      - Apache\n      - ElasticSearch\n      name: egress-ingress-0             #Policy Name\n      ports: tcp/9400\n    process:      #Process profile applicable to the Target group only, and only applies to self-learned and user create groups.\n       - action: deny     #Possible values are deny and allow\n          name: ls\n          path: /bin/ls        #This example shows it denies the ls command for this target.\n    target:\n      selector:\n        criteria:\n        - key: service\n          op: =\n          value: nginx-pod.demo\n        name: egress                     #Group Name\n      policymode: null\n- apiVersion: neuvector.com/v1\n  kind: NvSecurityRule\n  metadata:\n    name: ingress\n    namespace: demo\n  spec:\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"The CRD import behavior ignores the PolicyMode of any 'linked' group, leaving the Policy mode unchanged if the linked group already exists. If the linked group does not exist it will be automatically created and set to the default New Services Mode in Settings -> Configuration."})}),"\n",(0,s.jsx)("strong",{children:"Unsupported Export Group-Types"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Federated"}),"\n",(0,s.jsx)(n.li,{children:"IP-Based (unsupported for learned service IP only, custom user created IP groups are supported)"}),"\n"]}),"\n",(0,s.jsx)("strong",{children:"Import Scenarios"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The import will create new groups in the destination system if the groups do not yet exist in the destination environment, and the currently used Kubernetes user-context has the necessary permissions to access the namespaces configured in the CRD-yaml file to be imported."}),"\n",(0,s.jsx)(n.li,{children:"If the imported group exists in the destination system with different criteria or values, the import will be rejected."}),"\n",(0,s.jsx)(n.li,{children:"If the imported group exists in the destination system with identical configurations, we will reuse the existing group with different type."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"crd-samples-for-global-rules",children:"CRD Samples for Global Rules"}),"\n",(0,s.jsx)(n.p,{children:"The sample CRD below has two parts:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The first part is a NvClusterSecurityRule for the group named containers:\nThe target for this NvClusterSecurityRule is all containers. It has an ingress policy that does not allow any external connections (outside your cluster) to ssh into your containers. It also denies all containers from using the ssh process.  This defined global behavior applies to all containers."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The second part is a NvSecurityRule for alpine services:\nThe target is a service called nv.alpine.default in the 'default' namespace. Because it belongs to the all containers, it will inherit the above network policy and process rule. It also adds rules that don't not allow connections of HTTP traffic through port 80 to an external network. Also it not allow the running of the scp process."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Note that for service nv.alpine.default (defined as nv.xxx.yyy where xxx is the service name like alpine, yyy is the namespace like default) we can define policy mode that it is set to. Here it is defined as Protect mode (blocking all abnormal activity)."}),"\n",(0,s.jsx)(n.p,{children:"Overall since nv.alpine.defult is in protect mode, it will deny containers from running ssh and scp, and also will deny ssh connections from external or http to external."}),"\n",(0,s.jsx)(n.p,{children:"If you change the nv.alpine.defult policymode to monitor, then NeuVector will just log it when scp/ssh is invoked, or there are ssh connections from external or http to external."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nitems:\n- apiVersion: neuvector.com/v1\n  kind: NvClusterSecurityRule\n  metadata:\n    name: containers\n    namespace: default\n  spec:\n    egress: []\n    file: []\n    ingress:\n    - selector:\n        criteria: []\n        name: external\n      action: deny\n      applications:\n      - SSH\n      name: containers-ingress-0\n      ports: tcp/22\n    process:\n    - action: deny\n      name: ssh\n      path: /bin/ssh\n    target:\n      selector:\n        criteria:\n        - key: container\n          op: =\n          value: '*'\n        name: containers\n      policymode: null\n- apiVersion: neuvector.com/v1\n  kind: NvSecurityRule\n  metadata:\n    name: nv.alpine.default\n    namespace: default\n  spec:\n    egress:\n    - selector:\n        criteria: []\n        name: external\n      action: deny\n      applications:\n      - HTTP\n      name: external-egress-0\n      ports: tcp/80\n    file: []\n    ingress: []\n    process:\n    - action: deny\n      name: scp\n      path: /bin/scp\n    target:\n      selector:\n        criteria:\n        - key: service\n          op: =\n          value: alpine.default\n        - key: domain\n          op: =\n          value: default\n        name: nv.alpine.default\n      policymode: Protect\nkind: List\nmetadata: null\n"})}),"\n",(0,s.jsx)(n.p,{children:"To allow, or whitelist a process such as a monitoring process to run, just add a process rule with action: allow for the process name, and add the path.  The path must be specified for allow rules but is optional for deny rules."}),"\n",(0,s.jsx)(n.h3,{id:"updating-crd-rules-and-adding-to-existing-groups",children:"Updating CRD Rules and Adding to Existing Groups"}),"\n",(0,s.jsx)(n.p,{children:"Updating the CRD generated rules in NeuVector is as simple as updating the appropriate yaml file and applying the update:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"kubectl apply -f <crdrule.yaml>\n"})}),"\n",(0,s.jsx)(n.h4,{id:"dynamic-criteria-support-for-nvclustersecurityrule",children:"Dynamic criteria support for NvClusterSecurityRule"}),"\n",(0,s.jsx)(n.p,{children:"Multiple CRDs which change the criteria for existing custom group(s) are supported. This feature also allows the user to apply multiple CRDs at once, where the NeuVector behavior is to accept and queue the CRD so the immediate response to the user is always success.  During processing, any errors are reported into the console Notifications -> Events."})]})}function u(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},49633:(e,n,i)=>{i.d(n,{Z:()=>s});const s=i.p+"assets/images/export_crd-73ab3d5d1cd9c86370ea413efe762684.png"},75232:(e,n,i)=>{i.d(n,{Z:()=>s});const s=i.p+"assets/images/group_crd-ddd51407946c874eb18eda7b324c47e0.png"},11151:(e,n,i)=>{i.d(n,{Z:()=>l,a:()=>o});var s=i(67294);const r={},t=s.createContext(r);function o(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);